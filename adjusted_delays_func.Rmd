---
title: "VBZ Delays Extraction"
output: html_notebook
---

```{r global_options, include=TRUE}
knitr::opts_chunk$set(include = TRUE)
```

```{r}
library(tidyverse)
library(lubridate)
```


```{r}
#########################################################################################
################### Delay Increments Along Route Segments and At Stops  #################
#########################################################################################
# This function will return a tibble (tidyverse dataframe) of the delays greater than
# a certain integer, measured in minutes.  Minute values are rounded down from seconds.
#  PARAMETERS:
# small_tib -- a fahrzeitensollist .csv dataset from VBZ
# out_tib -- the name of an empty tibble
# work.line -- the bus or tram line of interest
# min_delay_seg_min -- the minimum delay time for delays on route segments, in minutes
# min_delay_von_min -- the minimum delay time for delays at the von stop
#
# Requires: tidyverse or dplyr library
#
# Contributers:  Peter B. Pearman  pbpearman@gmail.com
#
#
# small_tib  --a VBZ delay dataset
# out_tib    --the output dataset
# work.line  --the tram or bus line in question
# min_delay_seg_min --the threshold increment of additional delay on a segment
# min_delay_von_min --the threshold increment of additional delay at the 'von' stop
########################################################################################

delays <- function(small_tib,out_tib,work.line,min_delay_seg_min,min_delay_von_min){
  small_tib$halt_kurz_nach1 <- as.character(small_tib$halt_kurz_nach1)
  small_tib$halt_kurz_von1 <- as.character(small_tib$halt_kurz_von1)
  delay2 <- small_tib %>% 
    select(linie,umlauf_von,halt_id_nach,halt_id_von,datum_von,soll_ab_von,ist_ab_von,soll_an_nach,ist_an_nach1,
         soll_an_von,ist_an_von,halt_punkt_id_von,halt_punkt_id_nach,halt_kurz_von1,halt_kurz_nach1,halt_punkt_diva_von,halt_punkt_diva_nach) %>% 
    filter(linie == work.line) %>%
    
         
    mutate(soll_seg = soll_an_nach - soll_ab_von,    #delay during segments of the line
         ist_seg = ist_an_nach1 - ist_ab_von,
         delay_seg = soll_seg - ist_seg,
         
         soll_at_von = soll_ab_von - soll_an_von,     # delay at the stop (Haltstelle)
         ist_at_von = ist_ab_von - ist_an_von,
         delay_von = ist_at_von - soll_at_von)
  
        # now filter out lines that do not have at least one delay that is greater than the necessary minimum

  delay3 <- delay2 %>%
    mutate(delay_seg_min = floor(delay_seg/60), delay_von_min = floor(delay_von/60)) %>%
    filter(delay_seg_min >= min_delay_seg_min | delay_von_min >= min_delay_von_min)
  
  out_tib <- bind_rows(delay3,out_tib)
  return(out_tib)
}
```

```{r load_data, cache=TRUE,autodep=TRUE}
out_tib <- tibble()
temp=list.files('../data/fahrzeiten_data')
work.line <- 33
data_set=0
num_datasets = 12
min_delay_seg_min = 2
min_delay_von_min = 2
out_tib <- tibble()
for (i in temp){
  data_set <- data_set + 1
  print(i)
  delay1 <- read.csv(paste('../data/fahrzeiten_data/',i,sep=""),stringsAsFactors = FALSE)
  out_tib <- delays(delay1,out_tib,work.line,min_delay_seg_min,min_delay_von_min)
  if ((data_set>=num_datasets)==TRUE) break()
}
# make an index for QGIS plotting
out_tib$index <- paste(out_tib$linie,'-',out_tib$halt_punkt_id_von,'-',out_tib$halt_punkt_id_nach,sep='')
```

```{r}
#name<-"week1-2.csv"
#write_csv(out_tib,name)
```

```{r calculate_day_of_week}
out_tib$day.of.week <- factor(weekdays(as.POSIXct(out_tib$soll_ab_von,origin=dmy(out_tib$datum_von))),levels=c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"))
```


```{r make_output_data_for_graphing}
delay.seg1 <- out_tib %>%
        #select(delay_seg_min) %>%
        filter(delay_seg_min >= min_delay_seg_min) %>%
        mutate(type_val = "seg") %>%
        rename(delay = delay_seg_min, Type_of_value=type_val)

delay.von1 <- out_tib %>%
        #select(delay_von_min) %>%
        filter(delay_von_min >= min_delay_von_min) %>%
        mutate(type_val = "stop") %>%
        rename(delay = delay_von_min,Type_of_value = type_val)

delays_by_type <- bind_rows(delay.seg1,delay.von1)
```

```{r plot_data, include= TRUE, result="TRUE"}

plt <- ggplot(data=delays_by_type, aes(x=delay)) +
  geom_histogram(data=subset(delays_by_type,Type_of_value=="stop"),aes(fill=Type_of_value),alpha=0.3,bins=20) +
  geom_histogram(data=subset(delays_by_type,Type_of_value=="seg"),aes(fill=Type_of_value),alpha=0.3,bins=20) +
  scale_fill_manual(name="Counts", values = c("blue","red"),labels = c("Segments","Stops")) +
  facet_wrap(~day.of.week, nrow = 3) +
  ggtitle(" Delays Along Routes, By Day of Week") +
  theme(plot.title = element_text(hjust = 0.5))
  
    
  
```
```{r}
ggsave(filename="delays_routes_stops.png",plot=plt, width = 12.5, height = 8, units = 'cm', dpi=200)
```




